# Gazprom-Neft-SmartOil-Contest-2-Task-3
 Baseline for MAE = 137.2310
 
 ![Соревнование](https://boosters.pro/gazprom_smartoil_contest2)

# Gazprom Neft SmartOil Contest-2 (score -- 137.7980)

В данном kernel я привожу способ построения простейшей модели и её обучение на основе предоставленных данных. Особое внимание я уделил способу валидации. Так как валидация для временных рядов затруднена в связи с возможностью утечек данных. 

Я избрал подход, который основывается на следующей простой идее. Давайте будем делить нашу выборку на части по скважинам. Более формально запишем это так. Пусть есть набор скважин ![0](https://latex.codecogs.com/svg.latex?X_i), для каждой из которых есть последовательность измерений ![1](https://latex.codecogs.com/svg.latex?T_i%20=%20{T_{ij}}). Будем производть валидацию на различных подмножествах ![2](https://latex.codecogs.com/svg.latex?X_i). В задаче требуется предсказать значение переменной *Нефть, м3* на 12 месяцев вперёд.

Покажем, как будем строить множества для обучения и валидации. Важной заметкой является то, что в качестве метрики выбрана *MAE*. В данной задаче она не слишком корректна. Но именно она определяет способ построения алгоритмов и обучающих множеств. Так как *MAE* считается независимо для каждого измерения, предлагается строить независимые классификаторы для предсказания значения i-го месяца. Таким образом, для формирования ответа будем иметь 12 регрессоров.

Рассмотрим ![3](https://latex.codecogs.com/svg.latex?X_i). Будем делать предсказание на i-ый месяц вперёд по 12 предыдущим месяцам. Рассмотрим соответствующий набор ![](https://latex.codecogs.com/svg.latex?T_{i0},%20T_{i1},%20\cdots,%20T_{in_i}). Тогда примерами, обучающей выборки для 1-го классификатора можно считать:

![4](https://latex.codecogs.com/svg.latex?T_{i0},%20T_{i1},%20T_{i2},%20\cdots,%20T{i11}\}%20\rightarrow%20\{T_{i12})

![5](https://latex.codecogs.com/svg.latex?T_{i1},%20T_{i2},%20T_{i3},%20\cdots,%20T{i12}\}%20\rightarrow%20\{T_{i13})

![6](https://latex.codecogs.com/svg.latex?\cdots)

![7](https://latex.codecogs.com/svg.latex?T_{ik},%20T_{ik+1},%20T_{ik+2},%20\cdots,%20T{i12}\}%20\rightarrow%20\{T_{ik+12})

Обучающими примерами для 2-го классификатора будут:


![8](https://latex.codecogs.com/svg.latex?T_{i0},%20T_{i1},%20T_{i2},%20\cdots,%20T{i11}\}%20\rightarrow%20\{T_{i13})

![9](https://latex.codecogs.com/svg.latex?T_{i1},%20T_{i2},%20T_{i3},%20\cdots,%20T{i12}\}%20\rightarrow%20\{T_{i14})

![10](https://latex.codecogs.com/svg.latex?\cdots)

![11](https://latex.codecogs.com/svg.latex?T_{ik},%20T_{ik+1},%20T_{ik+2},%20\cdots,%20T{i12}\}%20\rightarrow%20\{T_{ik+13})

и так далее. Если для какая-то последовательность оказывается не достаточно длинной, то можно заполнить все значения до первого измерения нулями.

Немного обсудим то, какие скважины брать. Ответ очень прост. Берём всё, что попадется под руку. Т.е. объединяем test_before и train. Эти множества не пересекаются.
